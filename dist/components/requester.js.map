{"version":3,"sources":["../../src/components/requester.js"],"names":["Configurable","require","Monitorable","Component","axon","debug","SUBSET_IDENTIFIER","module","exports","Requester","constructor","advertisement","discoveryOptions","sock","types","type","set","timeout","process","env","COTE_REQUEST_TIMEOUT","send","socketSend","bind","startDiscovery","filterSubsetInSocks","subset","socks","possibleNodes","Object","values","discovery","nodes","filter","node","possibleSocks","map","find","remoteAddress","address","remotePort","port","args","length","enqueue","data","n","fn","pop","id","callbacks","push","write","pack","onAdded","obj","useHostNames","hostName","alreadyConnected","some","s","_host","connect","hasCallback","__timeout","sendOverSocket","Promise","resolve","reject","err","res","oppo","cb","timeoutHandle","setTimeout","messageCallback","Error","clearTimeout"],"mappings":"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","sourcesContent":["const Configurable = require('./configurable');\nconst Monitorable = require('./monitorable');\nconst Component = require('./component');\nconst axon = require('@dashersw/axon');\nconst debug = require('debug')('axon:req');\n\nconst SUBSET_IDENTIFIER = '__subset';\n\n\nmodule.exports = class Requester extends Monitorable(Configurable(Component)) {\n    constructor(advertisement, discoveryOptions) {\n        super(advertisement, discoveryOptions);\n\n        this.sock = new axon.types[this.type]();\n        this.sock.set('retry timeout', 0);\n        this.timeout = advertisement.timeout || process.env.COTE_REQUEST_TIMEOUT;\n\n        this.sock.send = this.socketSend.bind(this);\n        this.startDiscovery();\n    }\n\n    filterSubsetInSocks(subset, socks) {\n        // Find correct nodes\n        const possibleNodes = Object.values(this.discovery.nodes).filter((node) => {\n            return node.advertisement.subset == subset;\n        });\n\n        // Find corresponding sockets\n        const possibleSocks = possibleNodes.map((node) => {\n            return socks.find((sock) => {\n                return sock.remoteAddress == node.address &&\n                        sock.remotePort == node.advertisement.port;\n            });\n        }).filter((sock) => sock);\n\n        return possibleSocks;\n    }\n\n    // This function overwrites the axon socket's send() function.\n    // The socketSend() function's `this` is bound to this class in\n    // order to have access to the advertisement of other nodes.\n    // That advertisement contains each node's `subset` properties, which are needed\n    // to find specific subset Responders and their corresponding socks.\n    socketSend(...args) {\n        // (1) Original logic from https://github.com/dashersw/axon/blob/master/lib/sockets/req.js#L94\n        let { socks } = this.sock;\n        // Enqueue if no socks connected yet\n        if (!socks || !socks.length) {\n            debug('no connected peers');\n            return this.sock.enqueue(args);\n        }\n        // (1) end\n\n        // The following part chooses either a subset or all connected socks depending on the\n        // existence of the SUBSET_IDENTIFIER\n        const data = args[0];\n        const subset = data[SUBSET_IDENTIFIER];\n\n        let possibleSocks = subset ? this.filterSubsetInSocks(subset, socks) : socks;\n        // Enqueue if the correct nodes did not connect yet/does not exist\n        if (!possibleSocks.length) return this.sock.enqueue(args);\n\n        // Balance between available\n        const sock = possibleSocks[this.sock.n++ % possibleSocks.length];\n\n        // Save callback. In this context it will always have a context as it is called by sendOverSocket()\n        // (2) Original logic from https://github.com/dashersw/axon/blob/master/lib/sockets/req.js#L88\n        let fn = args.pop();\n        fn.id = this.sock.id();\n        this.sock.callbacks[fn.id] = fn;\n        args.push(fn.id);\n        // (2) end\n\n        // Remove possible subset identifier from message\n        delete args[0][SUBSET_IDENTIFIER];\n\n        // Send over sock\n        // (3) Original logic from https://github.com/dashersw/axon/blob/master/lib/sockets/req.js#L94\n        sock.write(this.sock.pack(args));\n        // (3) end\n    };\n\n    onAdded(obj) {\n        super.onAdded(obj);\n\n        const address = this.constructor.useHostNames ? obj.hostName : obj.address;\n\n        const alreadyConnected = this.sock.socks.some((s) =>\n            (this.constructor.useHostNames ? s._host == obj.hostName : s.remoteAddress == address) &&\n             s.remotePort == obj.advertisement.port);\n\n        if (alreadyConnected) return;\n\n        this.sock.connect(obj.advertisement.port, address);\n    }\n\n    send(...args) {\n        const hasCallback = typeof args[args.length - 1] == 'function';\n        const timeout = args[0].__timeout || this.timeout;\n\n        if (hasCallback) return sendOverSocket(this.sock, timeout, ...args);\n\n        return new Promise((resolve, reject) => {\n            sendOverSocket(this.sock, timeout, ...args, (err, res) => {\n                if (err) return reject(err);\n                resolve(res);\n            });\n        });\n    }\n\n    get type() {\n        return 'req';\n    }\n    get oppo() {\n        return 'rep';\n    }\n};\n\nfunction sendOverSocket(sock, timeout, ...args) {\n    if (!timeout) return sock.send(...args);\n\n    const cb = args.pop();\n\n    const timeoutHandle = setTimeout(() => {\n        delete sock.callbacks[messageCallback.id];\n        cb(new Error('Request timed out.'));\n    }, timeout);\n\n    const messageCallback = (...args) => {\n        clearTimeout(timeoutHandle);\n        cb(...args);\n    };\n\n    sock.send(...args, messageCallback);\n}\n"],"file":"requester.js"}