{"version":3,"sources":["../../src/components/subscriber.js"],"names":["Configurable","require","Monitorable","Component","axon","module","exports","advertisement","discoveryOptions","startDiscovery","sock","types","type","set","subscribesTo","forEach","topic","namespace","on","args","length","unshift","substr","emit","obj","address","constructor","useHostNames","hostName","alreadyConnected","socks","some","s","_host","remoteAddress","remotePort","port","connect","listener","formatTypeWithNamespace"],"mappings":";;;;;;;;;;;;AAAA,IAAMA,eAAeC,QAAQ,gBAAR,CAArB;AACA,IAAMC,cAAcD,QAAQ,eAAR,CAApB;AACA,IAAME,YAAYF,QAAQ,aAAR,CAAlB;AACA,IAAMG,OAAOH,QAAQ,gBAAR,CAAb;;AAEAI,OAAOC,OAAP;AAAA;;AACI,wBAAYC,aAAZ,EAA2BC,gBAA3B,EAA6C;AAAA;;AAAA,4HACnCD,aADmC,EACpBC,gBADoB;;AAGzC,cAAKC,cAAL;;AAEA,cAAKC,IAAL,GAAY,IAAIN,KAAKO,KAAL,CAAW,MAAKC,IAAhB,CAAJ,EAAZ;AACA,cAAKF,IAAL,CAAUA,IAAV,CAAeG,GAAf,CAAmB,eAAnB,EAAoC,CAApC;;AAEA,cAAKN,aAAL,CAAmBO,YAAnB,GAAkC,MAAKP,aAAL,CAAmBO,YAAnB,IAAmC,CAAC,GAAD,CAArE;;AAEA,cAAKP,aAAL,CAAmBO,YAAnB,CAAgCC,OAAhC,CAAwC,UAACC,KAAD,EAAW;AAC/C,gBAAIC,YAAY,EAAhB;AACA,gBAAI,MAAKV,aAAL,CAAmBU,SAAvB,EACIA,YAAY,MAAKV,aAAL,CAAmBU,SAAnB,GAA+B,IAA3C;;AAEJD,oBAAQ,cAAcC,SAAd,GAA0BD,KAAlC;;AAEA,aAAC,UAACA,KAAD,EAAW;AACR,sBAAKN,IAAL,CAAUQ,EAAV,CAAaF,KAAb,EAAoB,YAAa;AAAA,sDAATG,IAAS;AAATA,4BAAS;AAAA;;AAC7B,wBAAIA,KAAKC,MAAL,IAAe,CAAnB,EACID,KAAKE,OAAL,CAAaL,MAAMM,MAAN,CAAa,CAAb,CAAb,EADJ,KAGIH,KAAK,CAAL,IAAUF,YAAYE,KAAK,CAAL,CAAtB;;AAEJ,0BAAKI,IAAL,cAAaJ,IAAb;AACH,iBAPD;AAQH,aATD,EASGH,KATH;AAUH,SAjBD;AAVyC;AA4B5C;;AA7BL;AAAA;AAAA,gCA+BYQ,GA/BZ,EA+BiB;AAAA;;AACT,4HAAcA,GAAd;;AAEA,gBAAMC,UAAU,KAAKC,WAAL,CAAiBC,YAAjB,GAAgCH,IAAII,QAApC,GAA+CJ,IAAIC,OAAnE;;AAEA,gBAAMI,mBAAmB,KAAKnB,IAAL,CAAUA,IAAV,CAAeoB,KAAf,CAAqBC,IAArB,CAA0B,UAACC,CAAD;AAAA,uBAC/C,CAAC,OAAKN,WAAL,CAAiBC,YAAjB,GAAgCK,EAAEC,KAAF,IAAWT,IAAII,QAA/C,GAA0DI,EAAEE,aAAF,IAAmBT,OAA9E,KACCO,EAAEG,UAAF,IAAgBX,IAAIjB,aAAJ,CAAkB6B,IAFY;AAAA,aAA1B,CAAzB;;AAIA,gBAAIP,gBAAJ,EAAsB;;AAEtB,iBAAKnB,IAAL,CAAU2B,OAAV,CAAkBb,IAAIjB,aAAJ,CAAkB6B,IAApC,EAA0CX,OAA1C;AACH;AA3CL;AAAA;AAAA,2BA6COb,IA7CP,EA6Ca0B,QA7Cb,EA6CuB;AACf,8HAAgB,KAAKC,uBAAL,CAA6B3B,IAA7B,CAAhB,EAAoD0B,QAApD;AACH;AA/CL;AAAA;AAAA,gDAiD4B1B,IAjD5B,EAiDkC;AAC1B,gBAAIK,YAAY,EAAhB;AACA,gBAAI,KAAKV,aAAL,CAAmBU,SAAvB,EACIA,YAAY,KAAKV,aAAL,CAAmBU,SAAnB,GAA+B,IAA3C;;AAEJ,mBAAOA,YAAYL,IAAnB;AACH;AAvDL;AAAA;AAAA,4BAyDe;AACP,mBAAO,aAAP;AACH;AA3DL;AAAA;AAAA,4BA4De;AACP,mBAAO,aAAP;AACH;AA9DL;;AAAA;AAAA,EAA0CV,YAAYF,aAAaG,SAAb,CAAZ,CAA1C","file":"subscriber.js","sourcesContent":["const Configurable = require('./configurable');\nconst Monitorable = require('./monitorable');\nconst Component = require('./component');\nconst axon = require('@dashersw/axon');\n\nmodule.exports = class Subscriber extends Monitorable(Configurable(Component)) {\n    constructor(advertisement, discoveryOptions) {\n        super(advertisement, discoveryOptions);\n\n        this.startDiscovery();\n\n        this.sock = new axon.types[this.type]();\n        this.sock.sock.set('retry timeout', 0);\n\n        this.advertisement.subscribesTo = this.advertisement.subscribesTo || ['*'];\n\n        this.advertisement.subscribesTo.forEach((topic) => {\n            let namespace = '';\n            if (this.advertisement.namespace)\n                namespace = this.advertisement.namespace + '::';\n\n            topic = 'message::' + namespace + topic;\n\n            ((topic) => {\n                this.sock.on(topic, (...args) => {\n                    if (args.length == 1)\n                        args.unshift(topic.substr(9));\n                    else\n                        args[0] = namespace + args[0];\n\n                    this.emit(...args);\n                });\n            })(topic);\n        });\n    }\n\n    onAdded(obj) {\n        super.onAdded(obj);\n\n        const address = this.constructor.useHostNames ? obj.hostName : obj.address;\n\n        const alreadyConnected = this.sock.sock.socks.some((s) =>\n            (this.constructor.useHostNames ? s._host == obj.hostName : s.remoteAddress == address) &&\n             s.remotePort == obj.advertisement.port);\n\n        if (alreadyConnected) return;\n\n        this.sock.connect(obj.advertisement.port, address);\n    }\n\n    on(type, listener) {\n        return super.on(this.formatTypeWithNamespace(type), listener);\n    }\n\n    formatTypeWithNamespace(type) {\n        let namespace = '';\n        if (this.advertisement.namespace)\n            namespace = this.advertisement.namespace + '::';\n\n        return namespace + type;\n    }\n\n    get type() {\n        return 'sub-emitter';\n    }\n    get oppo() {\n        return 'pub-emitter';\n    }\n};\n"]}